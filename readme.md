# HorSat2

> HorSat2 版本 0.92 (c) 2015 by Naoki Kobayashi and Taku Terao

HorSat2 是一个用于高阶递归方案（HORS）的模型检查器。
Web 演示版请见：<http://www-kb.is.s.u-tokyo.ac.jp/~koba/horsat2/>

`horsat` 目录包含 HorSat2 的前身 HorSat 的源代码。

## 许可证

HorSat2 根据 GPL 3.0 版本条款发布。
请参阅 `COPYING.txt` 文件。

## 如何安装

安装前，您应拥有 OCaml 3.12 或更高版本。

运行以下命令：
```sh
make horsat2
```

## 用法

```sh
horsat2 [选项] <输入文件名>
```

### 选项

*   `-merge`: 备用模式（根据输入，可能比默认模式更快/更慢）。
*   `-noce`: 当给定属性不满足时，禁止打印反例。
*   `-cert`: 当给定属性满足时，打印常量和非终端符号的类型。
*   `-o <文件名>`: 将结果输出到 `<文件名>`。

### 输出

输出为以下两种情况之一：
*   `SATISFIED`: 如果属性得到满足。
*   `VIOLATED`: 如果属性未得到满足，后跟一个反例。

错误跟踪的格式取决于给定的自动机是确定性的还是交替的。

*   **确定性自动机**: 反例是树的一条路径，形式如下：
    `(a_1,d_1)(a_2,d_2)....(a_n,d_n)`。
    其中 `a_i` 是一个终端符号，`d_i` 是一个表示分支方向的非负整数。

*   **交替自动机**: 反例是一个违反该属性的有限子树。

## 输入文件格式

输入文件应包含一个文法部分，后跟一个树自动机的描述。

### 文法部分

文法部分应具有以下形式：

```
%BEGING
<重写规则 1>
....
<重写规则 n>
%ENDG
```

每个规则的形式应为 `"F x1 ... xn -> t."`。由第一条规则定义的非终端符号被解释为起始符号。

项的语法是：

```
t ::= x   (变量)
    | c   (终端符号)
    | F   (非终端符号)
    | t1 t2
```

请参阅 `examples/` 目录中的示例。

### 自动机部分

自动机部分应指定一个平凡的确定性树自动机（具有平凡接受条件的确定性布赫树自动机），或一个平凡的交替树自动机（具有平凡接受条件的自顶向下交替树自动机）。

#### 平凡确定性自动机

平凡确定性自动机的描述应包含以下部分：

```
%BEGINA
<转移规则 1>
...
<转移规则 m>
%ENDA
```

每个转移规则的形式应为 `"q a -> q1 ... qk"`。
这里，`q`, `q1`, ..., `qk` 是自动机的状态，`a` 是一个元数为 `k` 的树构造器。它应被理解为“当自动机在状态 `q` 读取节点 `a` 时，自动机应以状态 `qi` 继续读取第 i 个子节点”。第一条规则左侧的状态被解释为自动机的初始状态。

#### 平凡交替树自动机

平凡交-tree 自动机的描述应包含以下两个部分：

```
%BEGINR
<元数声明 1>
...
<元数声明 k>
%ENDR

%BEGINATA
<交替转移规则 1>
...
<交替转移规则 m>
%ENDATA
```

第一部分声明每个树构造器的元数。每个声明的形式应为 `"a -> <非负数>"`。例如，`"a->3"` 表示 `a` 的元数为 3。

第二部分声明交替树自动机的转移规则。每行的形式应为：

`q a -> <form>.`

其中 `<form>` 的语法是：

```
<form> ::= true
         | false
         | (i, q)
         | <form> /\ <form>
         | <form> \/ <form>
```

`(i,q)` 表示“以状态 q 读取第 i 个子节点”。例如，规则 `q a -> (1,q0) \/ ((1,q1) /\ (2,q2))` 的意思是：“在状态 `q` 读取 `a` 时，要么以状态 `q0` 读取第一个子节点，要么分别以状态 `q1` 和 `q2` 读取第一个和第二个子节点”。

## 示例输入

这是一个示例输入。

```
%BEGING
S -> F c.
F x -> br x (a (F (b x))).
%ENDG

%BEGINR
br -> 2.
a -> 1.
b -> 1.
c -> 0.
%ENDR

%BEGINATA
q0 br -> (1,q0) /\ (2,q1).
q1 br -> (1,q1) \/ (2,q1).
q0 a -> (1,q0).
q1 a -> false.
q0 b -> (1,q1).
q1 b -> (1,q1).
q0 c -> true.
q1 c -> true.
%ENDATA
```
